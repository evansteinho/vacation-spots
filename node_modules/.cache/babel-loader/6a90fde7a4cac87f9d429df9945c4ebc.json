{"ast":null,"code":"// This service completely hides the data store from the rest of the app.\n// No other part of the app knows how the data is stored. If anyone wants\n// to read or write data, they have to go through this service.\n\n// For this starter code, we use mock data, that is, data in memory that\n// is pretty arbitrary. The service functions to create and fetch articles\n// will just work on this fake data in memory.\n\n// This intent is for you to fork this starter code and then replace the\n// bodies of the service functions with code that fetches from a *real*\n// database like Firebase Firestore.\nimport { db } from \"../firebaseConfig\";\nimport { collection, query, getDocs, addDoc, orderBy, limit, Timestamp, doc } from \"firebase/firestore\";\nimport { deepCopy } from \"@firebase/util\";\nconst articles = {\n  sdkjfhshfskdlshjf: {\n    date: new Date(2021, 2, 16),\n    title: \"There’s a fair tomorrow\",\n    body: [\"Is a mháithrín an ligfidh tú chun aonaigh mé\", \"Is a mhuirnín óg ná healaí é\", \"Beidh aonach amárach in gContae an Chláir\", \"Cén mhaith domh é ní bheidh mé ann`\"].join(\"\\n\")\n  },\n  asjkdhalfkjsdjfhsd: {\n    date: new Date(2021, 9, 24),\n    title: \"Hello Everyone\",\n    body: \"It is a good day to learn React and Firebase\\n\".repeat(10)\n  }\n};\nexport async function createArticle(_ref) {\n  let {\n    title,\n    body\n  } = _ref;\n  // As this is just fake data for messing around, we'll throw in a quick\n  // and unreliable database id. In a real app, the id should b\n  const data = {\n    title,\n    body,\n    date: Timestamp.now()\n  };\n  const docRef = addDoc(collection(db, \"articles\"), data);\n  return {\n    id: (await docRef).id,\n    ...data\n  };\n}\nexport async function fetchArticles() {\n  // In storage the ids are separated from the data, but in this function\n  // we are going to combine the id and the data together.\n  const snapshot = await getDocs(query(collection(db, \"articles\"), orderBy(\"date\", \"desc\"), limit(20)));\n  return snapshot.docs.map(docs => ({\n    id: doc.id,\n    ...doc.data()\n  }));\n}","map":{"version":3,"names":["db","collection","query","getDocs","addDoc","orderBy","limit","Timestamp","doc","deepCopy","articles","sdkjfhshfskdlshjf","date","Date","title","body","join","asjkdhalfkjsdjfhsd","repeat","createArticle","data","now","docRef","id","fetchArticles","snapshot","docs","map"],"sources":["/Users/evansteinhoff/Desktop/webapp/blog-starter-app/src/services/articleService.js"],"sourcesContent":["// This service completely hides the data store from the rest of the app.\n// No other part of the app knows how the data is stored. If anyone wants\n// to read or write data, they have to go through this service.\n\n// For this starter code, we use mock data, that is, data in memory that\n// is pretty arbitrary. The service functions to create and fetch articles\n// will just work on this fake data in memory.\n\n// This intent is for you to fork this starter code and then replace the\n// bodies of the service functions with code that fetches from a *real*\n// database like Firebase Firestore.\nimport { db } from \"../firebaseConfig\"\nimport { collection, query, getDocs, addDoc, orderBy, limit, Timestamp, doc } from \"firebase/firestore\"\nimport { deepCopy } from \"@firebase/util\";\n\n\nconst articles = {\n  sdkjfhshfskdlshjf: {\n    date: new Date(2021, 2, 16),\n    title: \"There’s a fair tomorrow\",\n    body: [\n      \"Is a mháithrín an ligfidh tú chun aonaigh mé\",\n      \"Is a mhuirnín óg ná healaí é\",\n      \"Beidh aonach amárach in gContae an Chláir\",\n      \"Cén mhaith domh é ní bheidh mé ann`\",\n    ].join(\"\\n\"),\n  },\n  asjkdhalfkjsdjfhsd: {\n    date: new Date(2021, 9, 24),\n    title: \"Hello Everyone\",\n    body: \"It is a good day to learn React and Firebase\\n\".repeat(10),\n  },\n};\n\nexport async function createArticle({ title, body }) {\n  // As this is just fake data for messing around, we'll throw in a quick\n  // and unreliable database id. In a real app, the id should b\n  const data = {title, body, date: Timestamp.now()}\n  const docRef = addDoc(collection(db, \"articles\"), data)\n  return { id: (await docRef).id, ...data};\n\n}\n\nexport async function fetchArticles() {\n  // In storage the ids are separated from the data, but in this function\n  // we are going to combine the id and the data together.\n  const snapshot = await getDocs(\n    query(collection(db, \"articles\"), orderBy(\"date\", \"desc\"), limit(20))\n  )\n  return snapshot.docs.map((docs) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n}\n"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAASA,EAAE,QAAQ,mBAAmB;AACtC,SAASC,UAAU,EAAEC,KAAK,EAAEC,OAAO,EAAEC,MAAM,EAAEC,OAAO,EAAEC,KAAK,EAAEC,SAAS,EAAEC,GAAG,QAAQ,oBAAoB;AACvG,SAASC,QAAQ,QAAQ,gBAAgB;AAGzC,MAAMC,QAAQ,GAAG;EACfC,iBAAiB,EAAE;IACjBC,IAAI,EAAE,IAAIC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;IAC3BC,KAAK,EAAE,yBAAyB;IAChCC,IAAI,EAAE,CACJ,8CAA8C,EAC9C,8BAA8B,EAC9B,2CAA2C,EAC3C,qCAAqC,CACtC,CAACC,IAAI,CAAC,IAAI;EACb,CAAC;EACDC,kBAAkB,EAAE;IAClBL,IAAI,EAAE,IAAIC,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,EAAE,CAAC;IAC3BC,KAAK,EAAE,gBAAgB;IACvBC,IAAI,EAAE,gDAAgD,CAACG,MAAM,CAAC,EAAE;EAClE;AACF,CAAC;AAED,OAAO,eAAeC,aAAa,OAAkB;EAAA,IAAjB;IAAEL,KAAK;IAAEC;EAAK,CAAC;EACjD;EACA;EACA,MAAMK,IAAI,GAAG;IAACN,KAAK;IAAEC,IAAI;IAAEH,IAAI,EAAEL,SAAS,CAACc,GAAG;EAAE,CAAC;EACjD,MAAMC,MAAM,GAAGlB,MAAM,CAACH,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAAEoB,IAAI,CAAC;EACvD,OAAO;IAAEG,EAAE,EAAE,CAAC,MAAMD,MAAM,EAAEC,EAAE;IAAE,GAAGH;EAAI,CAAC;AAE1C;AAEA,OAAO,eAAeI,aAAa,GAAG;EACpC;EACA;EACA,MAAMC,QAAQ,GAAG,MAAMtB,OAAO,CAC5BD,KAAK,CAACD,UAAU,CAACD,EAAE,EAAE,UAAU,CAAC,EAAEK,OAAO,CAAC,MAAM,EAAE,MAAM,CAAC,EAAEC,KAAK,CAAC,EAAE,CAAC,CAAC,CACtE;EACD,OAAOmB,QAAQ,CAACC,IAAI,CAACC,GAAG,CAAED,IAAI,KAAM;IAClCH,EAAE,EAAEf,GAAG,CAACe,EAAE;IACV,GAAGf,GAAG,CAACY,IAAI;EACb,CAAC,CAAC,CAAC;AACL"},"metadata":{},"sourceType":"module"}