{"ast":null,"code":"import _regeneratorRuntime from\"/Users/evansteinhoff/Desktop/webapp/blog-starter-app/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";import _objectSpread from\"/Users/evansteinhoff/Desktop/webapp/blog-starter-app/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import _asyncToGenerator from\"/Users/evansteinhoff/Desktop/webapp/blog-starter-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";// This service completely hides the data store from the rest of the app.\n// No other part of the app knows how the data is stored. If anyone wants\n// to read or write data, they have to go through this service.\n// For this starter code, we use mock data, that is, data in memory that\n// is pretty arbitrary. The service functions to create and fetch articles\n// will just work on this fake data in memory.\n// This intent is for you to fork this starter code and then replace the\n// bodies of the service functions with code that fetches from a *real*\n// database like Firebase Firestore.\nimport{db}from\"../firebaseConfig\";import{collection,query,getDocs,addDoc,orderBy,limit,Timestamp,doc}from\"firebase/firestore\";export function createArticle(_x){return _createArticle.apply(this,arguments);}function _createArticle(){_createArticle=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee(_ref){var title,body,data,docRef;return _regeneratorRuntime().wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:title=_ref.title,body=_ref.body;// As this is just fake data for messing around, we'll throw in a quick\n// and unreliable database id. In a real app, the id should b\ndata={title:title,body:body,date:Timestamp.now()};docRef=addDoc(collection(db,\"articles\"),data);_context.t0=_objectSpread;_context.next=6;return docRef;case 6:_context.t1=_context.sent.id;_context.t2={id:_context.t1};_context.t3=data;return _context.abrupt(\"return\",(0,_context.t0)(_context.t2,_context.t3));case 10:case\"end\":return _context.stop();}}},_callee);}));return _createArticle.apply(this,arguments);}export function fetchArticles(){return _fetchArticles.apply(this,arguments);}function _fetchArticles(){_fetchArticles=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime().mark(function _callee2(){var snapshot;return _regeneratorRuntime().wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return getDocs(query(collection(db,\"articles\"),orderBy(\"date\",\"desc\"),limit(20)));case 2:snapshot=_context2.sent;return _context2.abrupt(\"return\",snapshot.docs.map(function(docs){return _objectSpread({id:doc.id},doc.data());}));case 4:case\"end\":return _context2.stop();}}},_callee2);}));return _fetchArticles.apply(this,arguments);}","map":{"version":3,"names":["db","collection","query","getDocs","addDoc","orderBy","limit","Timestamp","doc","createArticle","title","body","data","date","now","docRef","id","fetchArticles","snapshot","docs","map"],"sources":["/Users/evansteinhoff/Desktop/webapp/blog-starter-app/src/services/articleService.js"],"sourcesContent":["// This service completely hides the data store from the rest of the app.\n// No other part of the app knows how the data is stored. If anyone wants\n// to read or write data, they have to go through this service.\n\n// For this starter code, we use mock data, that is, data in memory that\n// is pretty arbitrary. The service functions to create and fetch articles\n// will just work on this fake data in memory.\n\n// This intent is for you to fork this starter code and then replace the\n// bodies of the service functions with code that fetches from a *real*\n// database like Firebase Firestore.\nimport { db } from \"../firebaseConfig\"\nimport { collection, query, getDocs, addDoc, orderBy, limit, Timestamp, doc } from \"firebase/firestore\"\n\nexport async function createArticle({ title, body }) {\n  // As this is just fake data for messing around, we'll throw in a quick\n  // and unreliable database id. In a real app, the id should b\n  const data = {title, body, date: Timestamp.now()}\n  const docRef = addDoc(collection(db, \"articles\"), data)\n  return { id: (await docRef).id, ...data};\n\n}\n\nexport async function fetchArticles() {\n  // In storage the ids are separated from the data, but in this function\n  // we are going to combine the id and the data together.\n  const snapshot = await getDocs(\n    query(collection(db, \"articles\"), orderBy(\"date\", \"desc\"), limit(20))\n  )\n  return snapshot.docs.map((docs) => ({\n    id: doc.id,\n    ...doc.data(),\n  }));\n}\n"],"mappings":"6aAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA,OAASA,EAAE,KAAQ,mBAAmB,CACtC,OAASC,UAAU,CAAEC,KAAK,CAAEC,OAAO,CAAEC,MAAM,CAAEC,OAAO,CAAEC,KAAK,CAAEC,SAAS,CAAEC,GAAG,KAAQ,oBAAoB,CAEvG,eAAsBC,cAAa,kDAOlC,mGAPM,oKAA+BC,KAAK,MAALA,KAAK,CAAEC,IAAI,MAAJA,IAAI,CAC/C;AACA;AACMC,IAAI,CAAG,CAACF,KAAK,CAALA,KAAK,CAAEC,IAAI,CAAJA,IAAI,CAAEE,IAAI,CAAEN,SAAS,CAACO,GAAG,EAAE,CAAC,CAC3CC,MAAM,CAAGX,MAAM,CAACH,UAAU,CAACD,EAAE,CAAE,UAAU,CAAC,CAAEY,IAAI,CAAC,iDACnCG,OAAM,kCAAEC,EAAE,cAArBA,EAAE,0BAAwBJ,IAAI,kIAExC,gDAED,eAAsBK,cAAa,gDAUlC,mGAVM,8KAGkBd,QAAO,CAC5BD,KAAK,CAACD,UAAU,CAACD,EAAE,CAAE,UAAU,CAAC,CAAEK,OAAO,CAAC,MAAM,CAAE,MAAM,CAAC,CAAEC,KAAK,CAAC,EAAE,CAAC,CAAC,CACtE,QAFKY,QAAQ,iDAGPA,QAAQ,CAACC,IAAI,CAACC,GAAG,CAAC,SAACD,IAAI,wBAC5BH,EAAE,CAAER,GAAG,CAACQ,EAAE,EACPR,GAAG,CAACI,IAAI,EAAE,GACb,CAAC,0DACJ"},"metadata":{},"sourceType":"module"}